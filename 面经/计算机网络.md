## 说明

此笔记基本拷贝小林的《图解网络》用作自己的学习复盘，偶尔会增加一些《自顶向下》的原话

## HTTP

## TCP/UDP

### TCP 三次握手与四次挥手

### TCP头部格式

![image-20220306205038392](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306205038392.png)

- 序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就 「累加」一次该「数据字节数」的⼤小。用来解决网络包乱序问题。 
- 确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数 据都已经被正常接收。用来解决不丢包的问题。 
- 控制位： 
  - ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须 设置为 1 。
  - RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。 
  - SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进行序列号初始值的设定。 
  - FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主 机之间就可以相互交换 FIN 位为 1 的 TCP 段。

### 为什么需要 TCP 协议？ TCP 工作在哪一层？

IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。

- 如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。 
- 因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是⽆损坏、⽆间隔、⾮冗余 和按序的

### 什么是 TCP ？

**TCP 是面向连接的、可靠的、基于字节流的传输层通信协议**

- 面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一 对多是⽆法做到的； 
- 可靠的：⽆论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端； 
- 字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进行传输。并且消息是「有序的」，当「前 一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的 报文会⾃动丢弃。

### 如何唯一确定一个 TCP 连接呢？

**TCP 四元组可以唯一的确定一个连接**

四元组包括如下： 

- 源地址 
- 源端口 
- ⽬的地址 
- ⽬的端口

- 源地址和⽬的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。 
- 源端口和⽬的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

### 有一个 IP 的服务器监听了一个端口，它的 TCP 的最⼤连接数是多少？

> [单台服务器上的并发TCP连接数可以有多少？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/405798293)

服务器通常固定在某个本地端口上监听，等待客户端的连接请求。

![image-20220306211714408](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306211714408.png)

通常我们是固定在某个服务器端口上监听客户端连接，而TCP连接是一个四元组，现在我们的目标地址和目标端口是不变的，那么可变量就是客户端IP和客户端端口了，所以最大TCP连接数就是`客户端的IP数 * 客户端的端口数`

**当然，服务端最⼤并发 TCP 连接数远不能达到理论上限。** 

- ⾸先主要是文件描述符限制，Socket 都是文件，所以⾸先要通过 ulimit 配置文件描述符的数⽬； 
- 另一个是内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的。

### UDP 和 TCP 有什么区别呢？分别的应用场景是？

UDP 不提供复杂的控制机制，利用 IP 提供面向「⽆连接」的通信服务。 UDP 协议真的⾮常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：![image-20220306212851930](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306212851930.png)

- ⽬标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。
-  包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。 
- 校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计

### TCP三次握手

![image-20220306213043368](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306213043368.png)

- 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态
- 客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态
- 服务端收到客户端的 SYN 报文后，⾸先服务端也随机初始化⾃⼰的序号（ server_isn ），将此序号填⼊ TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1 , 接着把 SYN 和 ACK 标志位置为 1 。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，⾸先该应答报文 TCP ⾸部 ACK 标志位置为 1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到 服务器的数据，之后客户端处于 ESTABLISHED 状态。 
- 服务器收到客户端的应答报文后，也进⼊ ESTABLISHED 状态。
- 从上面的过程可以发现第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的
- 一旦完成三次握⼿，双方都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以相互发送数 据了

### 为什么需要三次握手

#### **避免历史连接**

客户端接收到服务器端给自己的回应报文，会检查此报文的`ACK NUMBER`是否是自己期望的值，即`server_isn + 1`，如果不是，则发起`RST`报文终止连接

如果是两次握手，就不会有这个判断，可能被历史连接所干扰

**客户端连续发送多次 SYN 建⽴连接的报文，在网络拥堵情况下**：

-  一个「旧 SYN 报文」⽐「最新的 SYN 」 报文早到达了服务端； 
- 那么此时服务端就会回一个 SYN + ACK 报文给客户端； 
- 客户端收到后可以根据⾃身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中⽌这一次连接。

#### 同步双方序列号

在自顶向下里面讲过，序列号可以让对方知道这是否是一个重复的数据，然后抛弃掉。所以序列号很重要，需要同步。

**序列号作用**

- 接收方可以去除重复的数据； 
- 接收方可以根据数据包的序列号按序接收； （中间缺了一段数据怎么办，根据序列号继续返回该`ACK`，然后最后得到该数据，然后补上，获得连续的一串数据）
- 可以标识发送出去的数据包中， 哪些是已经被对方收到的

#### 避免资源浪费

如果只有「两次握⼿」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握⼿，服务器不清楚客户端是否收到了⾃⼰发送的建⽴连接的 ACK 确认信号，所以每收 到一个 SYN 就只能先主动建⽴一个连接，这会造成什么情况呢？

即两次握⼿会造成消息滞留情况下，服务器重复接受⽆用的连接请求 SYN 报文，⽽造成重复分配资源。

其实跟之前的第一种情况差不多

### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？![image-20220306215537640](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306215537640.png)

MTU ：一个网络包的最⼤⻓度，以太网中一般为 1500 字节；

MSS ：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最⼤⻓度

**IP层分片情况**

当 IP 层有一个超过 MTU ⼤小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成 若⼲片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由⽬标主机的 IP 层来进行重新组装后， 再交给上一层 TCP 传输层。 **这看起来井然有序，但这存在隐患的，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。**

因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时重传。当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时 后，就会重发「整个 TCP 报文（头部 + 数据）」。 **因此，可以得知由 IP 层进行分片传输，是⾮常没有效率的**

**TCP层分片**

所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不用 IP 分⽚了。 

经过 TCP 层分⽚后，如果一个 TCP 分⽚丢失后，进行重发时也是以 MSS 为单位，⽽不用重传所有的分⽚，⼤⼤ 增加了重传的效率

### SYN攻击

假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一 个 SYN 报文，就进⼊ SYN_RCVD 状态，**但服务端发送出去的 ACK + SYN 报文，⽆法得到未知 IP 主机的 ACK 应 答，久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务**

**避免方式**



### TCP四次挥手

![image-20220306221846056](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306221846056.png)



- 客户端打算关闭连接，此时会发送一个 TCP ⾸部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户 端进⼊ FIN_WAIT_1 状态。 
- 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进⼊ CLOSED_WAIT 状态。 
- 客户端收到服务端的 ACK 应答报文后，之后进⼊ FIN_WAIT_2 状态。 
- 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进⼊ LAST_ACK 状态。 
- 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进⼊ TIME_WAIT 状态 
- 服务器收到了 ACK 应答报文后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。 客户端在经过 2MSL 一段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭

你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥⼿。 

这⾥一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态

### 为什么要四次挥手

**就是因为还要等服务器处理完数据所以多了一次服务器向客户端发ACK的过程**

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
-  服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，⽽服务端可能还有数据需要处理和发送，等服 务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

### 为什么 TIME_WAIT 等待的时间是 2MSL？

MSL 是 Maximum Segment Lifetime，报文最⼤⽣存时间，它是任何报文在网络上存在的最⻓时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，⽽ IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最⼤路 由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： MSL 的单位是时间，⽽ TTL 是经过路由跳数。**所以 MSL 应该要⼤于等于 TTL 消耗为 0 的 时间，以确保报文已被⾃然消亡**

TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： **网络中可能存在来⾃发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。**

2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没 有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时

### 为什么需要 TIME_WAIT 状态

主动发起关闭连接的一方，才会有 TIME-WAIT 状态。

 需要 TIME-WAIT 状态，主要是两个原因： 

- 防⽌具有相同「四元组」的「旧」数据包被收到； 
- 保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从⽽帮助其正常关 闭

**防⽌具有相同「四元组」的「旧」数据包被收到； **

正常发送的时候有数据包因为网络延迟了，然后直到结束都没有到达，等到这个TCP四元组又一次建立连接的时候，上面那个数据包来了。这样子就会被上个连接的数据包所干扰。所以需要等待`2MSL`，这段时间足够报文被丢弃了

**原因⼆：保证连接正确关闭**

![image-20220306223623514](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306223623514.png)

- 如上图红⾊框框客户端四次挥⼿的最后一个 ACK 报文如果在网络中被丢失了，**此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSED 状态了，那么服务端则会一直处在 LASE_ACK 状态**。
- 当客户端发起建⽴连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建⽴的过程就会被终 ⽌

### TIME_WAIT 过多有什么危害

- 第一是内存资源占用； 
- 第⼆是对端口资源的占用，一个 TCP 连接⾄少消耗一个本地端口

**如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致⽆法创建新连接。**

**客户端受端口资源限制：** 

- 客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致⽆法创建新的连 接。 

**服务端受系统资源限制：** 

- 由于一个四元组表示 TCP 连接，理论上服务端可以建⽴很多连接，**服务端确实只监听一个端口 但是会把连接 扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当 服务端出现⼤重 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。**

### 如何优化 TIME_WAIT？

### TCP 重传、滑动窗口、流量控制、拥塞控制

#### TCP重传

但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？ 所以 TCP 针对数据包丢失的情况，会用重传机制解决。

**超时重传**

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确 认应答报文，就会重发该数据，也就是我们常说的超时重传。

TCP 会在以下两种情况发⽣超时重传： 数据包丢失 确认应答丢失

![image-20220306225756145](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306225756145.png)

**超时重传时间设置**

`RTT` 就是数据从网络一端传送到另一端所需的时间，也就是包的往返时间。

超时重传时间是以` RTO （Retransmission Timeout 超时重传时间）`表示

![image-20220306230754863](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306230754863.png)

- 当超时时间 RTO 较⼤时，重发就慢，丢了⽼半天才重发，没有效率，性能差； 
- 当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超 时，更多的超时导致更多的重发

根据上述的两种情况，我们可以得知，超时重传时间 RTO 的值应该略⼤于报文往返 RTT 的值。

**如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍**。 

也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。**两次超时，就说明网络环境差，不宜频繁反复发送**

**快速重传**

快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段

<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220307105142845.png" alt="image-20220307105142845" style="zoom:80%;" />

但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题？

根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。 为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。

**SACK方法**

这种方式需要在 TCP 头部「选项」字段⾥加一个 SACK 的东⻄，**它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。** 

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。

![image-20220306232437410](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306232437410.png)

如果要⽀持 SACK ，必须双方都要⽀持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）

**D-SACK**

Duplicate SACK ⼜称 D-SACK ，**其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**

![image-20220307111004505](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220307111004505.png)

- 「接收⽅」发给「发送⽅」的两个 ACK 确认应答都丢失了，所以发送⽅超时后，重传第⼀个数据包（3000 ~ 3499） 
- 于是「接收⽅」发现数据是重复收到的，于是回了⼀个 SACK = 3000~3500，告诉「发送⽅」 3000~3500 的 数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK 。 
- 这样「发送⽅」就知道了，数据没有丢，是「接收⽅」的 ACK 确认报⽂丢了。

#### 滑动窗口

我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。 这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率⽐较低的。

![image-20220306234036711](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306234036711.png)

为解决这个问题，TCP 引⼊了窗口这个概念。即使在往返时间较⻓的情况下，它也不会降低网络通信的效率。 那么有了窗口，就可以指定窗口⼤小，窗口⼤小就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值。

**窗口的实现实际上是操作系统开辟的一个缓存空间**，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已 发送的数据。**如果按期收到确认应答，此时数据就可以从缓存区清除。**

![image-20220306234119955](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306234119955.png)

> 窗⼝⼤小由哪⼀⽅决定

TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤小

这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来 发送数据，⽽不会导致接收端处理不过来。 所以，通常窗⼝的⼤小是由接收⽅的窗⼝⼤小来决定的。

**发送方的滑动窗口**

![image-20220306234146482](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220306234146482.png)

- 已发送并收到`ACK`确认的数据
- 已发送但未收到`ACK`确认的字段
- 未发送但总大小仍在接收方处理范围内
- 未发送但总大小超过接收方处理范围

**接收方的滑动窗口**

![image-20220307111444406](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220307111444406.png)

- RCV.WND ：表示接收窗⼝的⼤⼩，它会通告给发送⽅。 
- RCV.NXT ：是⼀个指针，它指向期望从发送⽅发送来的下⼀个数据字节的序列号，也就是 #3 的第⼀个字节。 
- 指向 #4 的第⼀个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND ⼤⼩的偏移量，就可以指向 #4 的 第⼀个字节了。

#### 流量控制

发送方不能⽆脑的发数据给接收方，要考虑接收方处理能⼒。 如**果一直⽆脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从⽽导致网络流重的⽆端的浪费**。 为了解决这种现象发⽣，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能⼒控制发送的数据量， 这就是所谓的流量控制。

>  操作系统缓冲区与滑动窗⼝的关系

我们假定了发送窗⼝和接收窗⼝是不变的，**但是实际上，发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中的，⽽操作系统的缓冲区，会被操作系统调整**

- 客户端发送 140 字节数据后，可⽤窗⼝变为 220 （360 - 140）。 
- 服务端收到 140 字节数据，但是服务端⾮常繁忙，应⽤进程只读取了 40 个字节，还有 100 字节占⽤着缓冲 区，于是接收窗⼝收缩到了 260 （360 - 100），最后发送确认信息时，将窗⼝⼤⼩通告给客户端。
- 客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 260。
- 客户端发送 180 字节数据，此时可⽤窗⼝减少到 80。
- 服务端收到 180 字节数据，但是应⽤程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于是接收窗 ⼝收缩到了 80 （260 - 180），并在发送确认信息时，通过窗⼝⼤⼩给客户端。
-  客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 80。
- 客户端发送 80 字节数据后，可⽤窗⼝耗尽。 
- 服务端收到 80 字节数据，但是应⽤程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗⼝收缩 到了 0，并在发送确认信息时，通过窗⼝⼤⼩给客户端。
- 客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 0。

> 如果发⽣了先减少缓存，再收缩窗⼝，就会出现丢包的现象。

为了防⽌这种情况发⽣，**TCP 规定是不允许同时减少缓存⼜收缩窗⼝的，⽽是采⽤先收缩窗⼝，过段时间再减少缓存，这样就可以避免了丢包情况。**

> 窗口关闭（可能造成死锁情况，需要定时器（持续定时器））

![image-20220307115205487](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220307115205487.png)

为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持 续计时器。 

如果持续计时器超时，就会发送窗⼝探测 ( Window probe ) 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩。

> 糊涂窗口综合症

如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。 

到最后，如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节， 这就是糊涂窗⼝综合症

要知道，我们的 TCP + IP 头有 40 个字节，为了传输那⼏个字节的数据，要达上这么⼤的开销，这太不经济 了。 就好像⼀个可以承载 50 ⼈的⼤巴⻋，每次来了⼀两个⼈，就直接发⻋。除⾮家⾥有矿的⼤巴司机，才敢这样玩， 不然迟早破产。

要解决这个问题也不难，⼤巴司机等乘客数量超过了 25 个，才认定可以发⻋。 现举个糊涂窗⼝综合症的栗⼦，考虑以下场景： 接收⽅的窗⼝⼤⼩是 360 字节，但接收⽅由于某些原因陷⼊困境，假设接收⽅的应⽤层读取的能⼒如下： 接收⽅每接收 3 个字节，应⽤程序就只能从缓冲区中读取 1 个字节的数据； 在下⼀个发送⽅的 TCP 段到达之前，应⽤程序还从缓冲区中读取了 40 个额外的字节

**所以，糊涂窗⼝综合症的现象是可以发⽣在发送⽅和接收⽅：** 

- 接收⽅可以通告⼀个⼩的窗⼝ 
- ⽽发送⽅可以发送⼩数据 

**于是，要解决糊涂窗⼝综合症，就解决上⾯两个问题就可以了** 

- 让接收⽅不通告⼩窗⼝给发送⽅ 
- 让发送⽅避免发送⼩数据

> 怎么让接收⽅不通告⼩窗⼝呢

当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间/2 ) ，也就是⼩于 MSS 与 1/2 缓存⼤⼩中的最⼩值时，就会向发送⽅通 告窗⼝为 0 ，也就阻⽌了发送⽅再发数据过来。 

等到接收⽅处理了⼀些数据后，窗⼝⼤⼩ >= MSS，或者接收⽅缓存空间有⼀半可以使⽤，就可以把窗⼝打开让发 送⽅发送数据过来。

> 怎么让发送⽅避免发送⼩数据呢？

发送⽅通常的策略: 使⽤ Nagle 算法，该算法的思路是延时处理，它满⾜以下两个条件中的⼀条才可以发送数据： 

- 要等到窗⼝⼤⼩ >= MSS 或是 数据⼤⼩ >= MSS 
- 收到之前发送数据的 ack 回包 只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件

#### 拥塞控制

前⾯的流量控制是避免「发送⽅」的数据填满「接收⽅」的缓存，但是并不知道⽹络的中发⽣了什么。

 ⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。

 **在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是 ⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放 ⼤....**

所以，TCP 不能忽略⽹络上发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低 发送的数据量。 于是，就有了拥塞控制，控制的⽬的就是避免「发送⽅」的数据填满整个⽹络。 

为了在「发送⽅」调节所要发送数据的量，定义了⼀个叫做「拥塞窗⼝」的概念。

> 什么是拥塞窗⼝？和发送窗⼝有什么关系呢？

**拥塞窗⼝ cwnd是发送⽅维护的⼀个的状态变量**，它会根据⽹络的拥塞程度动态变化的。

 我们在前⾯提到过发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。

拥塞窗⼝ cwnd 变化的规则：

- 只要⽹络中没有出现拥塞， cwnd 就会增⼤；
- 但⽹络中出现了拥塞， cwnd 就减少；

> 怎么知道当前⽹络是否出现了拥塞呢？

其实只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络出现了⽤拥塞

> 拥塞控制有哪些控制算法？

拥塞控制主要是四个算法：

- 慢启动 
- 拥塞避免 
- 拥塞发⽣ 
- 快速恢复

**慢启动**

TCP 在刚建⽴连接完成后，⾸先是有个慢启动的过程，这个慢启动的意思就是⼀点⼀点的提⾼发送数据包的数量， 如果⼀上来就发⼤量的数据，这不是给⽹络添堵吗？

**慢启动的算法记住⼀个规则就⾏：当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1**

这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦： 

- 连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。 
- 当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个 
- 当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个 
- 当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发 4 个，所以这⼀次能够发送 8 个。

![image-20220307122204948](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220307122204948.png)

> 那慢启动涨到什么时候是个头呢？

有⼀个叫慢启动⻔限 ssthresh （slow start threshold）状态变ᰁ。 

- 当 cwnd < ssthresh 时，使⽤慢启动算法。 
- 当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」。
- ⼀般来说 ssthresh 的⼤⼩是 65535 字节

**拥塞避免算法**

那么进⼊拥塞避免算法后，它的规则是：每当收到⼀个 ACK 时，cwnd 增加 1/cwnd。 

接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 

- 当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。

![image-20220307122451308](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220307122451308.png)

所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶段，但是增⻓速度缓慢了⼀些。

**拥塞发⽣**

当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种： 

- 超时重传 
- 快速重传 

这两种使⽤的拥塞发送算法是不同的，接下来分别来说说

> 发⽣超时重传的拥塞发⽣算法

当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。 这个时候，ssthresh 和 cwnd 的值会发⽣变化： 

- ssthresh 设为 cwnd/2 
- cwnd 重置为 1

![image-20220307122821336](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220307122821336.png)

接着，就᯿新开始慢启动，慢启动是会突然减少数据流的。这真是⼀旦「超时᯿传」，⻢上回到解放前。但是这种 ⽅式太激进了，反应也很强烈，会造成⽹络卡顿

> 发⽣快速᯿传的拥塞发⽣算法

还有更好的⽅式，前⾯我们讲过「快速᯿传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的 ACK，于是发送端就会快速地᯿传，不必等待超时再᯿传

TCP 认为这种情况不严᯿，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下

- cwnd = cwnd/2 ，也就是设置为原来的⼀半; 
- ssthresh = cwnd ; 
- 进⼊快速恢复算法

**快速恢复**

快速᯿传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个᯿复 ACK 说明⽹络也不那么糟 糕，所以没有必要像 RTO 超时那么强烈

正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：

- cwnd = cwnd/2 ，也就是设置为原来的⼀半;
- ssthresh = cwnd ;

然后，进⼊快速恢复算法如下：

- 拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 
- ᯿传丢失的数据包； 
- 如果再收到᯿复的 ACK，那么 cwnd 增加 1； 
- 如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说 明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进⼊ 拥塞避免状态

![image-20220307123022233](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220307123022233.png)

也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓

## IP

