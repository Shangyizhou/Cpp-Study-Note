### 进程和线程的区别和联系

- 进程是**用某种方法将相关的资源集中在一起的一种抽象**。进程有存放程序正文和数据以及其他资源的地址空间，这些资源中有打开的文件，子进程，定时器，信号处理程序等。我们让进程对他们进行管理
- 另一个概念，进程中有一个用于执行的线程，线程中有程序计数器，用来记录执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还有一个堆栈，用来记录执行历史。**线程是在`CPU`上被调度执行的实体**

**自己的话**

- 进程是操作系统进行资源分配基本单位，我们说一个运行起来的程序叫做进程，它运行需要内存（地址空间），需要程序计数器，需要CPU支持，所以它需要利用系统的种种资源，所以我们称它为资源分配的基本单位。
- 线程则是`CPU`上被调度执行的实体，是程序执行的最小单位）；线程可以完成某个子任务，`CPU`执行指令需要程序计数器，所以线程有程序计数器，寄存器，堆栈。
- 一个进程可以有多个线程，但是一个线程只能属于一个进程。
- 进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。
- 进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。

### 同一个进程内的线程共享什么资源

- 共享相同地址空间
- 共享全局变量
- 共享打开的文件
- 共享代码段

**但是寄存器和栈还有程序计数器是独立的**

### 进程状态

进程的状态

- 运行态（该时刻进程占用`CPU`）
- 就绪态（可运行，但是其他进程占据`CPU`）
- 阻塞态（不可运行，即使该进程占据`CPU`）

另外两个基本状态

- 创建状态（new）：进程正在被创建时的状态； 
- 结束状态（Exit）：进程正在从系统中消失时的状态

![image-20220223224226886](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220223224226886.png)

- **转换一**

进程可以执行`pause`系统调用阻塞进程，从而使该进程进入阻塞状态。或者当一个进程要从管道中读取数据，但是管道内无数据时，也会被阻塞

- **转换二和转换三**

这是由调度程序引起的，系统认为一个运行进程占用`CPU`时间足够了，就会让其他进程占用`CPU`，这会发生`转换二`。而其他进程也占用`CPU`到达时限了，系统又会将`CPU`给会原来进程使用，这时发生`转换三`

- **转换四**

当进程等来一个外部事件发生时（比如一些输入到达），则发生转换四，如果此时没有其它进程运行，则会立即触发转换三，该进程运行

### 线程模型

**用户线程**

- 在用户空间实现的线程，由用户态的线程库来完成对线程的管理
- 进程内设置有线程控制块记录创建的线程情况（线程表）
- 对于内核而言，它看不到用户级别的线程，而只能看到这个进程。

**优点**

- 每个进程都需要有它私有的线程控制块（TCB）列表，⽤来跟踪记录它各个线程状态信息（PC、栈指 针、寄存器），TCB 由⽤户级线程库函数来维护，可⽤于不⽀持线程技术的操作系统；
-  ⽤户线程的切换也是由线程库函数来完成的，⽆需⽤户态与内核态的切换，所以速度特别快；

**缺点**

- 由于操作系统不参与线程的调度，如果⼀个线程发起了系统调⽤⽽阻塞，那进程所包含的⽤户线程都 不能执⾏了。 
- 当⼀个线程开始运⾏后，除⾮它主动地交出 CPU 的使⽤权，否则它所在的进程当中的其他线程⽆法运⾏，因为⽤户态的线程没法打断当前运⾏中的线程，它没有这个特权，只有操作系统才有，但是⽤户线程不是由操作系统管理的。 
- 由于时间片分配给进程，故与其他进程⽐，在多线程执⾏时，每个线程得到的时间⽚较少，执⾏会⽐ 较慢

**内核线程**

- 内核线程是由操作系统管理的，线程对应的 TCB ⾃然是放在操作系统⾥的，这样线程的创建、终⽌和管理 都是由操作系统负责
- 所有阻塞线程的调用都是以系统调用的形式实现，当然代价会更大。当一个线程阻塞，内核可以运行同一个进程中的另一个线程或者运行另一个进程中的线程

**优点**

- 在⼀个进程当中，如果某个内核线程发起系统调⽤⽽被阻塞，并不会影响其他内核线程的运⾏；
- 分配给线程，多线程的进程获得更多的 CPU 运⾏时间；

**缺点**

- 在⽀持内核线程的操作系统中，由内核来维护进程和线程的上下⽂信息，如 PCB 和 TCB； 
- 线程的创建、终⽌和切换都是通过系统调⽤的⽅式来进⾏，因此对于系统来说，系统开销⽐较⼤；（回收节省资源）

**轻量级进程**

- 轻量级进程（Light-weight process，LWP）**是内核⽀持的⽤户线程，⼀个进程可有⼀个或多个 LWP，每 个 LWP 是跟内核线程⼀对⼀映射的**，也就是 LWP 都是由⼀个内核线程⽀持。

在 LWP 之上也是可以使⽤⽤户线程的，那么 LWP 与⽤户线程的对应关系就有三种：

- `1 : 1` ，即⼀个 LWP 对应 ⼀个⽤户线程；
  - 优点：实现并⾏，当⼀个 LWP 阻塞，不会影响其他 LWP； 
  - 缺点：每⼀个⽤户线程，就产⽣⼀个内核线程，创建线程的开销较⼤
- `N : 1` ，即⼀个 LWP 对应多个⽤户线程； 
  - 优点：⽤户线程要开⼏个都没问题，且上下⽂切换发⽣⽤户空间，切换的效率较⾼； 
  - 缺点：⼀个⽤户线程如果阻塞了，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利⽤ CPU 的
- `M : N` ，即多个 LMP 对应多个⽤户线程
  - 优点：综合了前两种优点，⼤部分的线程上下⽂发⽣在⽤户空间，且多个线程⼜可以充分利⽤多核 CPU 的资源

### Linux理论上可以创建的进程数量，一个进程可以创建多少线程

**理论创建进程数量**

我们用`pid_t`来表示一个进程的`pid`，因此能表示的进程的范围一定不会超过`pid_t`类型的大小，`pid_t`实际上就是一个`short`类型变量。

```c++
sys/types.h:

//pid_t就是一个short类型变量，实际表示的是内核中的进程表的索引
typedef short pid_t; /* used for process ids */
```

`2的16次方 = 65536`这只是一个理论值，实际上，由于内存等系统资源的限制，根本不会同时有这么多的进程存在。

**理论创建线程数量**

**创建一个线程会占用多少内存，这取决于分配给线程的调用栈大小**，可以用`ulimit -s`命令来查看大小。

```c++
ulimit -s
8192	//10M
```

一个进程的虚拟内存是4G，在Linux32位平台下，内核分走了1G，留给用户用的只有3G，于是我们可以想到，创建一个线程占有了10M内存，总共有3G内存可以使用。于是可想而知，最多可以创建差不多300个左右的线程。

### 协程

最开始是非抢占式任务，但是如果有人写代码崩了，那么就一起崩，无法把CPU让出。后来防着这种情况，就变成了抢占式任务，操作系统防着大家，每个进程固定就给这么多时间片，运行结束就换人，有人代码写崩了，也可以换人。

后来，多线程普及。线程也做成了抢占式多任务，但是这会涉及到线程同步问题，大家商量锁，互斥等操作比较麻烦，这样子代码执行的任务逻辑比较复杂，不能向以前一样很顺畅的走下去。

此时，非抢占式多任务的好处就出来了：大家都一家人，都想齐心合力把事情做好；因此，当“我”事情没做完而且并不会耽误太久时，你们就应该等我；而一旦我事情做完了、或者需要等待网络信号/磁盘准备好时，“我”也会痛快的主动交出控制权。

这个做法，使得协作式多任务之间执行权的交接点极为明晰；那么只要逻辑考虑清楚了，锁就是完全没必要的——反正不会抢夺嘛，事情没告一段落我就不会交执行权；交执行权之前确保不存在“悬置的、未确定未提交的修改”，脏读脏写就杜绝了。

**因此，协程这个概念的提出，使得程序逻辑更为清晰，执行更加可控。**

**协程不能让OS知道自己的存在。**

**这是因为，OS并没有协程支持；如果你想让OS知道你的存在，那么它就会把你当线程调度——于是抢占式多任务就又回来了，“协程”这个“协”字就名不副实了。**

为什么说这个“无法在CPU上并行”的束缚恰恰是协程的优点呢？

因为它是协作式多任务，不存在执行绪紊乱的可能。

没错，每次执行中，协程之间的具体执行顺序可能千变万化；但**协程执行权切换**却**只会发生在用户明确放弃执行权之后**——比如你明确执行了yield语句时。

- 协程实质上是一种在用户空间实现的协作式多线程架构。
- [也来谈谈协程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/147608872)

### 进程间通信方法

进程之间的通信方式主要有六种，包括**管道，信号量，消息队列，信号，共享内存，套接字**。

* 管道：
  * 管道是半双工的，双方需要通信的时候，需要建立两个管道。
  * 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。
  * 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的
  * 匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。
  * 管道的底层实现 https://segmentfault.com/a/1190000009528245
* 信号量（可以实现多进程互斥同步）：
  * **信号量初始化为`1`代表互斥**
    * 进程 A 在访问共享内存前，先执⾏了 P 操作，由于信号量的初始值为 1，故在进程 A 执⾏ P 操作后 信号量变为 0，表示共享资源可⽤，于是进程 A 就可以访问共享内存。
    *  若此时，进程 B 也想访问共享内存，执⾏了 P 操作，结果信号量变为了 -1，这就意味着临界资源已 被占⽤，因此进程 B 被阻塞。 **直到进程 A 访问完共享内存，才会执⾏ V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执⾏ V 操作，使信号量恢复到初始 值 1**
  * **信号量初始化为`0`代表同步**
    * 假设A、B分别为生产者和消费者，**A进行V操作生产，B进行P操作消费**
    * 如果进程 B ⽐进程 A 先执⾏了，那么执⾏到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没⽣产数据，于是进程 B 就阻塞等待； 
    * 接着，当进程 A ⽣产完数据后，执⾏了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作 的进程 B； 最后，进程 B 被唤醒后，意味着进程 A 已经⽣产了数据，于是进程 B 就可以正常读取数据了。
  * 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。
  * 信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。
* 信号：
  * 上⾯说的进程间通信，都是常规状态下的⼯作模式。**对于异常情况下的⼯作模式，就需要⽤「信号」的⽅ 式来通知进程**
  * **信号是进程间通信机制中唯⼀的异步通信机制（意味着内核管理），因为可以在任何时候发送信号给某⼀进程**，⼀旦有信号产 ⽣，我们就有下⾯这⼏种，⽤户进程对信号的处理⽅式。
    * 1.执⾏默认操作。Linux 对每种信号都规定了默认操作，例如，上⾯列表中的 SIGTERM 信号，就是终⽌进 程的意思。
    * 2.捕捉信号。我们可以为信号定义⼀个信号处理函数。当信号发⽣时，我们就执⾏相应的信号处理函数。 
    * 3.忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应⽤ 进程⽆法捕捉和忽略的，即 SIGKILL 和 SEGSTOP ，它们⽤于在任何时候中断或结束某⼀进程
* 共享内存：
  * 消息队列的读取和写⼊的过程，都会有发⽣⽤户态与内核态之间的消息拷⻉过程。那共享内存的⽅式，就 很好的解决了这⼀问题
  * **共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。**
  * 共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写⼊的东⻄， 另外⼀个进程⻢上就能看到了，都不需要拷⻉来拷⻉去，传来传去，⼤⼤提⾼了进程间通信的速度。
  * 一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。
* 消息队列：
  * 管道的通信⽅式是效率低的，因此管道不适合进程间频繁地交换数据
  * 消息队列的通信模式就可以解决。⽐如，A 进程要给 B 进程发送消息，**A 进程把数据放在 对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。**同理，B 进程要给 A 进 程发送消息也是如此
  * **消息队列是保存在内核中的消息链表**，在发送数据时，会分成⼀个⼀个独⽴的数据单元，也就是消 息体（数据块），消息体是⽤户⾃定义的数据类型，**消息的发送⽅和接收⽅要约定好消息体的数据类型， 所以每个消息体都是固定⼤⼩的存储块，不像管道是⽆格式的字节流数据。**如果进程从消息队列中读取了 消息体，内核就会把这个消息体删除
  * 消息队列⽣命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，⽽前⾯ 提到的匿名管道的⽣命周期，是随进程的创建⽽建⽴，随进程的结束⽽销毁。
  * **消息队列不适合⽐较⼤数据的传输**，因为在内核中每个消息体都有⼀个最⼤⻓度的限制，同时所有队列所 包含的全部消息体的总⻓度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB ， 它们以字节为单位，分别定义了⼀条消息的最⼤⻓度和⼀个队列的最⼤⻓度。
  *  **消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销，因为进程写⼊数据到内核中的消息队列 时，会发⽣从⽤户态拷⻉数据到内核态的过程**，同理另⼀进程读取内核中的消息数据时，会发⽣从内核态 拷⻉数据到⽤户态的过程
  * 消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。
  * 可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。
* 套接字：
  * 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。

### 进程间调度方法

- **先来先服务算法**

  - 每次从就绪队列选择最先进⼊队列的进程，然后⼀直运⾏，直到进程退出或被阻塞，才会继续从队列中选择第⼀个进程接着运⾏。

  **缺点**

  - 当⼀个⻓作业先运⾏了，那么后⾯的短作业等待的时间就会很⻓，不利于短作业。 FCFS 对⻓作业有利，适⽤于 CPU 繁忙型作业的系统，⽽不适⽤于 I/O **繁忙型作业的系统**

- **最短作业优先调度算法**

  - 它会优先选择运⾏时间最短的进程来运⾏，这有助于提⾼系统的吞吐量

  **缺点**

  - 这显然对⻓作业不利，很容易造成⼀种极端现象。 ⽐如，⼀个⻓作业在就绪队列等待运⾏，⽽这个就绪队列有⾮常多的短作业，那么就会使得⻓作业不断的往后推，周转时间变⻓，致使⻓作业⻓期不会被运⾏

- **高响应比优先调度算法**

  - 每次进⾏进程调度时，先计算「响应⽐优先级」，然后把「响应⽐优先级」最⾼的进程投⼊运⾏，「响应 ⽐优先级」的计算公式

  ![image-20220304224237263](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220304224237263.png)

  **特点**

  - 如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应⽐」就越⾼，这样短作业的 进程容易被选中运⾏；
  - 如果两个进程「要求的服务时间」相同时，「等待时间」越⻓，「响应⽐」就越⾼，这就兼顾到了⻓作业进程，因为进程的响应⽐可以随时间等待的增加⽽提⾼，当其等待时间⾜够⻓时，其响应⽐便可 以升到很⾼，从⽽获得运⾏的机会；

- **时间⽚轮转调度算法**

  - 每个进程被分配⼀个时间段，称为时间⽚（Quantum），即允许该进程在该时间段中运⾏
  - 如果时间⽚⽤完，进程还在运⾏，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外⼀个进 程； 如果该进程在时间⽚结束前阻塞或结束，则 CPU ⽴即进⾏切换；

  **特点**

  - 如果时间⽚设得太短会导致过多的进程上下⽂切换，降低了 CPU 效率； 
  - 如果设得太⻓⼜可能引起对短作业进程的响应时间变⻓。

- **最高优先级调度算法**

  - 调度程序能从就绪队列中选择最⾼优先级的进程进⾏运⾏，这称为最⾼优先级（Highest Priority First，HPF）调度算法

  **优先级可分为静态优先级和动态优先级**

  - 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运⾏时间优先级都不会变化；
  - 动态优先级：根据进程的动态变化调整优先级，⽐如如果进程运⾏时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升⾼其优先级，也就是随着时间的推移增加等待进程 的优先级。

  **该算法也有两种处理优先级高的方法，非抢占式和抢占式：** 

  - 非抢占式：当就绪队列中出现优先级⾼的进程，运⾏完当前进程，再选择优先级⾼的进程。
  - 抢占式：当就绪队列中出现优先级⾼的进程，当前进程挂起，调度优先级⾼的进程运⾏。

### 进程的执行过程

### 死锁的产生和恢复

### 孤儿进程和僵尸进程

* 孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。
* 僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。

### PCB和进程地址空间

PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。

PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息



进程地址空间内有：

* 代码段text：存放程序的二进制代码
* 初始化的数据Data：已经初始化的变量和数据
* 未初始化的数据BSS：还没有初始化的数据
* 栈
* 堆

### 内核空间和用户空间