# C++语法

## 智能指针

- 智能指针其作用是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏这种情况的发生。
- 程序员记住要释放内存，但是有多个指针都指向了此处内存，没有设置`ptr == nullptr`，造成了悬空指针情况

### auto_ptr

```c++
auto_ptr<std::string> p1 (new string ("hello"));
auto_ptr<std::string> p2;
p2 = p1; //auto_ptr 不会报错.
```

此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 `auto_ptr` 的缺点是：存在潜在的内存崩溃问题！

### unique_ptr(代替auto_ptr)

保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资源泄露特别有用。

```c++
unique_ptr<string> p3 (new string (auto));//#4
unique_ptr<string> p4；//#5
p4 = p3;//此时会报错
```

### shared_ptr（共享型，强引用）

- 可以赋值，多个`shared_ptr`指向同一内存

- 当引用技术为0时，最后一个指针释放指向的内存并且将其置为`nullptr`

- ```c++
  use_count();//查看资源共享数
  release();//当前指针释放所有权,计数减一
  ```

- 一般使用`make_shared<>`

- 不用使用的`get()`获取的裸指针，如果`delete`此裸指针指向的内存，那么`shared_ptr`在引用计数为`0`时也会释放内存，导致重复释放

- 不要将`get()`得到的裸指针再赋值给另一个`shared_ptr`，这会导致另一个独立的计数开始。会重复释放内存

- 不要混合使用`new`和`shared_ptr`，`new`得到了一个有名指针，其仍然可以访问那块内存，尽管被释放了，这会导致非法访问

### weak_ptr（共享型，弱引用）

`weak_ptr` 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 `shared_ptr` 管理的对象。进⾏ 该对象的内存管理的是那个强引用的 `shared_ptr`。 

`weak_ptr` 只是提供了对管理对象的⼀个访问⼿段。`weak_ptr` 设计的⽬的是为配合  `shared_ptr` ⽽引⼊的⼀种智能指针来协助 `shared_ptr` ⼯作，它只可以从⼀个 ` shared_ptr` 或另 ⼀个 `weak_ptr` 对象构造,，它的构造和析构不会引起引用记数的增加或减少。

### weak_ptr避免循环引用

```c++
#include <iostream>
#include <memory>
using namespace std;

class B; // 前置声明
class A {
public:
    shared_ptr<B> ptr;
    A() {
        cout << "A的构造函数" << endl;
    }
    ~A() {
        cout << "A的析构函数" << endl;
    }
};

class B {
public:
    shared_ptr<A> ptr;
    B() {
        cout << "B的构造函数" << endl;
    }
    ~B() {
        cout << "B的析构函数" << endl;
    }
};

int main()
{
    //倘若我们写出这样的代码，那么理想情况下，每次循环结束释放内存，调用析构函数
    //但是因为循环引用的关系，导致引用计数都为2，循环结束减一，并不会调用类A,B的析构函数释放内存
    //我们的类需要互相有一个指向对面的指针，但是又不想影响彼此的引用计数，那么就使用weak_ptr
    shared_ptr<A> pa(new A());//智能指针pa管理对象(pa.use_count() == 1)  
    shared_ptr<B> pb(new B());//智能指针pb管理对象(pb.use_count() == 1) 
    pa -> ptr = pb;//pa的成员变量指针指向了pb,导致pb的引用计数+1, pb.use_count() == 2
    pb -> ptr = pa;//pb的成员变量指针指向了pa,导致pa的引用计数+1, pa.use_count() == 2
    
    //所以结束的时候,pa的引用技术减去1,但是因为pb内部有成员指向pa,导致pa.use_count() != 0,所以不会析构掉该指针指向对象
    //也因此,pa指向对象不被销毁,其指针仍然指向pb指向对象,使其pb.use_count() != 0,pb也不会被释放


    return 0;
}
```

将其中一个改为`weak_ptr`即可

## C++内存分配情况

栈：由编译器管理分配和回收，存放局部变量和函数参数。 

堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会 出现内存泄漏和空闲碎⽚的情况。 

全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量 和静态变量。 

常量存储区：存储常量，⼀般不允许修改。 代码区：存放程序的⼆进制代码

## C++ 中的指针参数传递和引用参数传递

## C++ 中 const 和 static 关键字（定义，用途）

**static 作用：控制变量的存储⽅式和可⻅性。**

**作用⼀：修饰局部变量：**⼀般情况下，对于局部变量在程序中是存放在栈区的，并且局部的⽣ 命周期在包含语句块执⾏结束时便结束了。但是如果用 static 关键字修饰的话，该变量便会存 放在静态数据区，其⽣命周期会⼀直延续到整个程序执⾏结束。但是要注意的是，虽然用 static 对局部变量进⾏修饰之后，其⽣命周期以及存储空间发⽣了变化，但其作用域并没有改 变，作用域还是限制在其语句块。

**作用⼆：修饰全部变量：**对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个 ⼯程中其它源⽂件被访问(添加 extern进⾏声明即可)。用 static 对全局变量进⾏修饰改变了其 作用域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅

**作用三：修饰函数：**用 static 修饰函数，情况和修饰全局变量类似，也是改变了函数的作用 域

**作用四：修饰类：**如果 C++ 中对类中的某个函数用 static 修饰，则表示该函数属于⼀个类⽽ 不是属于此类的任何特定对象；如果对类中的某个变量进⾏ static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在⼀个副本，可以通过；类和对象去调用。

**作用五：类成员/类函数声明 static**

- 函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配 ⼀次，因此其值在下次调用时仍维持上次的值； 
- 在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；  
- 在模块内的 static 函数只可被这⼀模块内的其它函数调用，这个函数的使用范围被限制在 声明它的模块内；  在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有⼀份拷⻉；  
- 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类 的 static 成员变量。 
- static 类对象必须要在类外进⾏初始化，static 修饰的变量先于对象存在，所以 static 修 饰的变量要在类外初始化； 
- 由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针， this 指针是指向本对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰的类成员； 
- static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指针调用的，所以不能为 virtual；虚函数的调用关系， this->vptr->ctable->virtual function。

## C 和 C++ 区别 （函数/类/struct/class）

- 基本语句上没有太大区别
- C++增加了命名空间
- C++增加了函数重载
- C++在`malloc`和`free`的基础上增加了new和delete，方便对于对象的管理
- C++增加了引用的概念，实际是方向不能改变的指针
- 类与对象
  - explicit
  - =default
  - =delete
  - override
- C++的`struct`可以增设成员函数，跟`class`差不多，只是默认为`public`，而`class`默认为`private`
- C++增设了模板，提供了强大的`STL  C11`



## C++中重载和重写，重定义的区别

**重载**

翻译⾃ overload，是指同⼀可访问区内被声明的⼏个具有不同参数列表的同名函数，依赖于 C++函数名字的修饰会将参数加在后⾯，可以是参数类型，个数，顺序的不同。根据参数列表 决定调用哪个函数，重载不关⼼函数的返回类型。

**重写**

翻译⾃ override，派⽣类中重新定义⽗类中除了函数体外完全相同的虚函数，注意被重写的函 数不能是 static 的，⼀定要是虚函数，且其他⼀定要完全相同。要注意，重写和被重写的函数 是在不同的类当中的，重写函数的访问修饰符是可以不同的，尽管 virtual 中是 private 的，派 ⽣类中重写可以改为 public。

**重定义**

派⽣类᯿新定义⽗类中相同名字的⾮ virtual 函数

参数列表 和返回类型都可以不同，即⽗类中除了定义成 virtual 且完全相同的同名函数才 不会被派⽣类中的同名函数所隐藏（᯿定义）

## 介绍 C++ 所有的构造函数



## C++ 的四种强制转换

C++ 的四种强制转换包括：static_cast, dynamic_cast, const_cast, reinterpret_cast

- static_cast：明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换（派⽣类->基类）安全，下⾏转换（基类->派⽣类） 不安全，所以 主要执⾏⾮多态的转换操作； 
- dynamic_cast：专⻔用于派⽣类之间的转换，type-id 必须是类指针，类引用或 void*，对 于下⾏转换是安全的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不 ⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。 
- const_cast：专⻔用于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四 个转换符中唯⼀⼀个可以操作常量的转换符。 
- reinterpret_cast：不到万不得已，不要使用这个转换符，⾼危操作。使用特点： 从底层 对数据进⾏᯿新解释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以 把指针转换为数组；可以在指针和引用之间进⾏肆⽆忌惮的转换。

## 指针和引用的区别

指针和引用都是⼀种内存地址的概念，区别呢，指针是⼀个实体，引用只是⼀个别名。 

在程序编译的时候，将指针和引用添加到符号表中。 

指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量 名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有 const 和⾮ const 区别，甚⾄可以为空，sizeof 指针得到的是指针类型的⼤⼩。

⽽对于引用来说，它只是⼀块内存的别名，在添加到符号表的时候，是将"引用变量名-引用对象的地址"添加到符号表中，符号表⼀经完成不能改变，所以引用必须⽽且只能在定义时被绑 定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和⾮ const 区别。

- `sizeof`引用得到代表对象的大小，而`sizeof`指针得到指针本身的大小
- 参数传递中，指针解引用才可以得到对象，⽽直接对引用进⾏的修改会直接作用到引用对象上。
- 作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址， 传递的是变量的地

## 野(wild)指针与悬空(dangling)指针有什么区别？如何避免？

野指针(wild pointer)：就是没有被初始化过的指针。⽤ gcc -Wall 编译, 会出现 used uninitialized 警告。 

悬空指针：是指针最初指向的内存已经被释放，且未被设置为`nullptr`的⼀种指针

⽆论是野指针还是悬空指针，都是指向⽆效内存区域(这⾥的⽆效指的是"不安全不可控")的指 针。 访问"不安全可控"(invalid)的内存区域将导致"Undefined Behavior"。 

如何避免使⽤野指针？在平时的编码中，养成在定义指针后且在使⽤之前完成初始化的习惯或 者使⽤智能指针。

## 说一下 const 修饰指针如何区分？



## 简单说一下函数指针

## 堆和栈区别

**栈**

编译器管理，需要时由编译自动分配空间，不需要时回收空间，一般保存局部变量和函数参数

连续的内存空间，在函数调⽤的时候，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是 函数的各个参数。

本次函数调⽤结束时，局部变ᰁ先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程 序由该点继续运⾏，不会产⽣碎⽚

栈是⾼地址向低地址扩展，栈低⾼地址，空间较⼩。

**堆**

由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会 造成内存泄漏的问题。

不连续的空间，实际上系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到 第⼀个⼤于等于申请⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存 ⼤⼩，⽅便 delete 回收空间⼤⼩。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这 也是产⽣内存碎⽚的原因。

堆是低地址向⾼地址扩展，空间交⼤，较为灵活。

## 堆快一点还是栈快一点？（字节提前批一面）

栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

## new / delete ，malloc / free 区别

都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。

new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名

执⾏ new 实际上执⾏两个过程：

- 1.分配未初始化的内存空间（malloc）；
- 2.使⽤对象的构造 函数对空间进⾏初始化；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现 异常，则⾃动调⽤ delete 释放内存

## volatile 和 extern 关键字



## define 和 const 区别（编译阶段、安全性、内存占用等）

联系：它们都是定义常量的一种方法。

  区别：

* define定义的常量没有类型，只是进行了简单的替换（预编译），可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。
* define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。
* define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。
* const可以定义函数而define不可以。

## 在C\+\+中const的用法（定义，用途）

* const修饰类的成员变量时，表示常量不能被修改
* const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数

## 计算类的大小(内存对齐)

```C++
class A {};
int main(){
  cout<<sizeof(A)<<endl;// 输出 1;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 1;
  return 0;
}

```

空类的大小是1， 在C\+\+中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。

当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。

空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。

```C++
class A { virtual Fun(){} };
int main(){
  cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);
  A a; 
  cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);
  return 0;
}
```

因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节

```C++
class A { static int a; };
int main(){
  cout<<sizeof(A)<<endl;// 输出 1;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 1;
  return 0;
}
```

静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小

```C++
class A { int a; };
int main(){
  cout<<sizeof(A)<<endl;// 输出 4;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 4;
  return 0;
}
```

```C++
class A { static int a; int b; };;
int main(){
  cout<<sizeof(A)<<endl;// 输出 4;
  A a; 
  cout<<sizeof(a)<<endl;// 输出 4;
  return 0;
}
```

静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节

## 面向对象的三大特性，并举例说明

**封装**

把客观事物封装成抽象的类，类可以把自己的数据和方法只让信任的类或者对象操纵，隐藏必要的信息。

**继承**

是指可以让某个类型的对象获得另⼀个类型的对象的属性的⽅法。它⽀持按级分类的概念。继 承是指这样⼀种能⼒：它可以使⽤现有类的所有功能，并在⽆需᯿新编写原来的类的情况下对 这些功能进⾏扩展。通过继承创建的新类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”、 “⽗类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要实现继承，可以通过“继承”和“组 合”来实现。

**多态**

就是向不同的对象发送同⼀个消息，不同对象在接收时会产⽣不同的⾏为（即⽅法）。即⼀个 接⼝，可以实现多种⽅法。

多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编 译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调 ⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。

## 多态的实现

## 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（*）

⾸先我们来说⼀下，C++中多态的表象，在基类的函数前加上 virtual 关键字，在派⽣类中᯿ 写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类，就调 ⽤派⽣类的函数，如果是基类，就调⽤基类的函数。

实际上，当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的 地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃ ⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣ 类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数 中完成的。

后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象 的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。

**补充**：如果基类中没有定义成 virtual，那么进⾏ Base B; Derived D; Base *p = D; p- >function(); 这种情况下调⽤的则是 Base 中的 function()。

因为基类和派⽣类中都没有虚函数 的定义，那么编译器就会认为不⽤留给动态多态的机会，就事先进⾏函数地址的绑定（早绑定），详述过程就是，定义了⼀个派⽣类对象，⾸先要构造基类的空间，然后构造派⽣类的⾃ 身内容，形成⼀个派⽣类对象，那么在进⾏类型转换时，直接截取基类的部分的内存，编译器 认为类型就是基类，那么（函数符号表［不同于虚函数表的另⼀个表］中）绑定的函数地址也 就是基类中函数的地址，所以执⾏的是基类的函数。

## 编译器处理虚函数表应该如何处理

对于派⽣类来说，编译器建⽴虚函数表的过程其实⼀共是三个步骤

- 拷⻉基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表 
- 当然还有⼀个基类的虚函数表和派⽣类⾃身的虚函数表共⽤了⼀个虚函数表，也称为某个 基类为派⽣类的主基类 
- 查看派⽣类中是否有᯿写基类中的虚函数， 如果有，就替换成已经᯿写的虚函数地址； 查看派⽣类是否有⾃身的虚函数，如果有，就追加⾃身的虚函数到⾃身的虚函数表中

## 析构函数⼀般写成虚函数的原因

直观的讲：是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的 对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那么编译器根据指 针类型就会认为当前对象的类型是基类，调⽤基类的析构函数 （该对象的析构函数的函数地 址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏

如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函 数，再执⾏基类的析构函数，成功释放内存

## 构造函数为什么一般不定义为虚函数

- 虚函数调⽤只需要知道“部分的”信息，即只需要知道函数接⼝，⽽不需要知道对象的具体 类型。但是，我们要创建⼀个对象的话，是需要知道对象的完整信息的。特别是，需要知 道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；
- ⽽且从⽬前编译器实现虚函数进⾏多态的⽅式来看，虚函数的调⽤是通过实例化之后对象的虚函数表指针来找到虚函数的地址进⾏调⽤的，如果说构造函数是虚的，那么虚函数表指针则是不存在的，⽆法找到对应的虚函数表来调⽤虚函数，那么这个调⽤实际上也是违 反了先实例化后调⽤的准则

> Effective的例子
>
> 如果`Base`类有一个虚函数，并且其构造函数调用了虚函数，那么我们再设计一个子类继承`Base`类，然后生成子类对象。
>
> 那么，子类会先调用`Base`构造函数，然后调用虚函数，此时虚函数是子类重写的，会利用到子类的成员变量，可是子类还未被构造，这会导致不可名状的后果

## 构造函数或析构函数中调用虚函数会怎样

同上

在析构函数中也是同理，派⽣类执⾏了析构函数后，派⽣类的⾃身成员呈现未定义的状态，那 么在执⾏基类的析构函数中是不可能调⽤到派⽣类᯿写的⽅法的。所以说，我们不应该在构在 函数或析构函数中调⽤虚函数，就算调⽤⼀般也不会达到我们想要的结果

> 即，派生类调用析构函数，先析构自己的，再析构父类的，析构自己的之后成员变量无了，其中包含了基类的一些成员，这个时候又调用了虚函数，那就会出问题了。

## 析构函数的作用，如何起作用？

## 构造函数的执行顺序？析构函数的执行顺序？

**构造函数顺序**

- 基类构造函数。如果有多个基类，则构造函数的调⽤顺序是某类在类派⽣表中出现的顺序，⽽不是它们在成员初始化表中的顺序。 
- 成员类对象构造函数。如果有多个成员类对象则构造函数的调⽤顺序是对象在类中被声明 的顺序，⽽不是它们出现在成员初始化表中的顺序。 
- 派⽣类构造函数

**析构函数顺序**

- 调⽤派⽣类的析构函数； 
- 调⽤成员类对象的析构函数； 
- 调⽤基类的析构函数。

## 纯虚函数 （应用于接口继承和实现继承）

纯虚函数的出现就是为了让继承可以出现多种情况

- 有时我们希望派⽣类只继承成员函数的接⼝ 
- 有时我们⼜希望派⽣类既继承成员函数的接⼝，⼜继承成员函数的实现，⽽且可以在派⽣ 类中可以᯿写成员函数以实现多态 
- 有的时候我们⼜希望派⽣类在继承成员函数接⼝和实现的情况下，不能᯿写缺省的实现

其实，声明⼀个纯虚函数的⽬的就是为了让派⽣类只继承函数的接⼝，⽽且派⽣类中必需提供 ⼀个这个纯虚函数的实现，否则含有纯虚函数的类将是抽象类，不能进⾏实例化

使用`override`

## 静态绑定和动态绑定的介绍

说起静态绑定和动态绑定，我们⾸先要知道静态类型和动态类型，静态类型就是它在程序中被 声明时所采⽤的类型，在编译期间确定。动态类型则是指“⽬前所指对象的实际类型”，在运⾏期间确定（程序由数据和指令构成）

静态绑定，⼜名早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发 ⽣在编译期间。

动态绑定，⼜名晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发⽣在运 ⾏期间。

⽐如说，virtual 函数是动态绑定的，⾮虚函数是静态绑定的，缺省参数值也是静态绑定的。这 ⾥呢，就需要注意，我们不应该᯿新定义继承⽽来的缺省参数，因为即使我们᯿定义了，也不 会起到效果。因为⼀个基类的指针指向⼀个派⽣类对象，在派⽣类的对象中针对虚函数的参数 缺省值进⾏了᯿定义， 但是缺省参数值是静态绑定的，静态绑定绑定的是静态类型相关的内 容，所以会出现⼀种派⽣类的虚函数实现⽅式结合了基类的缺省参数值的调⽤效果，这个与所 期望的效果不同。



## 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）

当出现类的等号赋值时，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调 ⽤默认的拷⻉函数－即浅拷⻉，它能够完成成员的⼀⼀复制。当数据成员中没有指针时，浅拷 ⻉是可⾏的。

但当数据成员中有指针时，如果采⽤简单的浅拷⻉，则两类中的两个指针指向同⼀个地址，当 对象快要结束时，会调⽤两次析构函数，⽽导致指ᰀ指针的问题。

**例子**

成员变量有指针

## 什么情况下会调用拷贝构造函数(三种情况)

- ⼀个对象以值传递的⽅式传⼊函数体，需要拷⻉构造函数创建⼀个临时对象压⼊到栈空间 中。 
- ⼀个对象以值传递的⽅式从函数返回，需要执⾏拷⻉构造函数创建⼀个临时对象作为返回 值。 
- ⼀个对象需要通过另外⼀个对象进⾏初始化。

## 为什么拷贝构造函数必需时引用传递，不能是值传递？

为了防⽌递归调⽤。当⼀个对象需要以值⽅式进⾏传递时，编译器会⽣成代码调⽤它的拷⻉构 造函数⽣成⼀个副本，如果类 A 的拷⻉构造函数的参数不是引⽤传递，⽽是采⽤值传递，那 么就⼜需要为了创建传递给拷⻉构造函数的参数的临时对象，⽽⼜⼀次调⽤类 A 的拷⻉构造 函数，这就是⼀个⽆限递归

## 结构体内存对齐方式和为什么要进⾏内存对齐？

⾸先我们来说⼀下结构体中内存对⻬的规则

- 对于结构体中的各个成员，第⼀个成员位于偏移为 0 的位置，以后的每个数据成员的偏移 ᰁ必须是 min(#pragma pack() 制定的数，数据成员本身⻓度) 的倍数。 
- 在所有的数据成员完成各⾃对⻬之后，结构体或联合体本身也要进⾏对⻬，整体⻓度是 min(#pragma pack()制定的数，⻓度最⻓的数据成员的⻓度) 的倍数。

**那么内存对⻬的作⽤是什么呢？**

- 经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块 的，块的⼤⼩可以是 2，4，8，16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏ 读取的，块的⼤⼩称为内存读取粒度。⽐如说 CPU 要读取⼀个 4 个字节的数据到寄存器 中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，那么直接将 0-3 四个字节完 全读取到寄存器中进⾏处理即可。
- 如果数据是从 1 字节开始的，就⾸先要将前 4 个字节读取到寄存器，并再次读取 4-7 个 字节数据进⼊寄存器，接着把 0 字节，5，6，7 字节的数据剔除，最后合并 1，2，3，4 字节的数据进⼊寄存器，所以说，当内存没有对⻬时，寄存器进⾏了很多额外的操作，⼤ ⼤降低了 CPU 的性能。

## 内存泄漏的定义，如何检测与避免？

内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现 ⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的 ⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。

**如何检测内存泄漏**

- ⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可 ⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。 
- 还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配 且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。 
- 当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具 来进⾏内存泄漏的检测。







