## 运输层

### 概述和运输层服务

运输层协议为运行在不同主机上的**应用进程**之间提供了逻辑通信。（看起来两个主机之间好似相连了一般），实际上还依靠了路由器和链路的相连，但这些不在运输层考虑范围之中。

运输层协议是在主机中实现的而不是路由器中实现的。在发送端，运输层将从应用程序进程接收到的报文转换成运输层的报文段。实现方法是将应用层的报文分成较小的块，并为每个块加上运输层的首部形成运输层报文段。然后继续发送到网络层，网络层将其封装成网络层报文并向目的地发送。接收端也会相应的处理得到的报文，然后分析报文首部再一层层往上传递

**运输层和网络层的关系**

- 网络层为`主机`之间提供了逻辑通信

- 运输层为`主机上的进程`之间提供了逻辑通信

张家和王家进行通信，张三收集家人的邮件然后交给邮局，邮局再运输给李家的李四。

- 在这里，将`张家`和`王家`看成不同的主机
- `张三的家人`和`李四的家人`就是各自主机上的进程
- `张三`和`李四`就是运输层的协议
- 邮政服务就是网络层协议
- 邮件上的字符就是应用层报文（应用层进程的报文给运输层 -> 各个姐妹的邮件交给张三）

再进一步联想，如果邮局说传递过去至少要三天，那么张三和李四也只能告诉亲戚最快要三天。所以运输层协议提供的服务受制于网络层协议的模型。（当然，我们可以在应用层增设很多方法来保证信息的正确传达）

**因特网运输层概述**

先介绍下网络层，其中有一个协议是`IP协议`，它会尽最大的努力交付但不保证交付成功。所以`IP`是不可靠的服务。

每个主机都有一个`IP`地址

再来看运输层的两个经典协议

`UDP`

- 提供不可靠，无连接的服务

`TCP`

- 提供可靠的，面向连接的，基于字节流的服务

我们将主机间`IP`的交付服务扩展为运行在端系统上的两个进程之间的交付服务的这个行为叫做 **运输层的多路复用与多路分解** 

> `UDP`和`TCP`作用

`UDP `和`TCP`可以通过在其报文段首部中包含差错检查字段以提供完整性检查。`UDP`仅能提供最低限度的运输层服务，即在进程间信息的交付和完整性检查。

> `TCP`作用

`TCP`提供了几种附加服务

- 它提供可靠数据传输，通过使用流量控制，序号，确认和定时器等工具，`TCP`确保正确地、按序地、将数据从发送进程交付给接收进程。这样，`TCP`就将两个主机间的不可靠`IP`服务转换成了一种进程间的可靠数据传输服务
- `TCP`还提供拥塞控制防止任何一条`TCP`连接用过多流量来淹没主机间的链路和交换设备。`TCP`力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽`(指网络系统的通信链路传输数据的能力，即单位时间内从网络中的某一点到另一点所能通过的最高数据率)`
- `补充:发送发给接受方发送数据，如果发送方每1秒发送100包，接收方只能1秒处理50包，会出现什么现象呢？接收方会在缓存中大量缓存接受的包，直到缓存区满了。满了之后会怎么样？接着就会出现最不能容忍的情况，缓冲区溢出，也就是丢包的现象。所以接收方一定要在缓冲区快满的时候通知发送方让他降低发送速度，这就是链路层的流量控制。流量控制用于确保实体发送的数据不会覆盖接受实体已接收的数据。`

而`UDP`流量是不可调节的，使用`UDP`传输的应用程序可以根据其需要以其愿意的任何速率发送数据

### 多路复用与多路分解

> 一个例子

假设我的主机正在下载`Web`页面，同时运行一个`FTP会话`和两个`Telnet`会话，那么在一个主机上就同时有四个进程在运行，我的主机在接收数据的情况下，运输层需要把网络层接收的数据定向到这四个进程中的一个（对应的数据送到对应的进程）。

一个进程有一个或多个`socket`，`socket`是网络向进程传递数据和进程向网络传递数据的媒介。所以，接受主机的运输层实际是将数据交付给对应的`socket`而不是直接给进程。而一个主机上可能有多个`socket`，运输层报文段该如何定向到指定的`socket`呢？

这就需要报文中的字段了，运输层检查报文中的字段，然后标识出`接收socket`，进而将报文定向到该`socket`。

- 将运输层报文段中的数据交付到正确套接字的工作称为多路分解
- 在不同`socket`中收集数据，并封装好这些数据生成报文段并发给网络层，这样的工作成为多路复用

> 既然运输层有多路复用的需求，那么我们可以研究一下报文段的设计

- 套接字要有唯一标识符
- 每个报文段有特殊字段来指示该报文段所要交付到的套接字`(源端口号字段和目的端口号字段)`
- 端口号是`16bit`的数，其大小在`0~65525 = 2的16次方`之间
- `0~1023`是周知端口号，受限制，需保留给`HTTP`和`FTP`之类的应用层协议使用

**无连接的多路复用与多路分解(UDP如何发送数据)**

- `A`的运输层创建一个运输层报文，其中包括`应用数据、源端口号、目的端口号...`，然后运输层将报文段传递到网络层。
- 网络层将报文段封装到一个`IP`报文中，并尽力交付给对方主机。
- 报文到达`B`，接收主机运输层就检查该报文段的目的端口号，并将该报文段交付给有相应端口号的套接字
- 如果`B`要使用`UDP`协议发送数据给`A`，那么正好使用之前报文获得的`源端口号、目的端口号`，填到对应的运输层报文中，（此时的`目的端口号`就是`A`的`源端口号`，`源端口号`就是`A`的`目的端口号`），然后发送给网络层，网络层发送给对方。

一个`UDP`套接字由一个二元组来标识，该二元组包含`目的IP地址`和`目的端口号`。如果两个`UDP`报文段有不同的`源IP地址`或`源端口号`，但具有相同的`目的IP地址`和`目的端口号`，那么两个报文段将通过相同的`socket`被定向到相同的进程

**换句话说，UDP的socket只含有目的IP和目的port，所以不检查源头，只要对方的目的相同就定向到相同的process，而不管对方的来头是不是一样的**

**面向连接的多路复用与多路分解(TCP如何发送数据)**

- `TCP`套接字由一个四元组`源IP地址、源端口号、目的IP地址、目的端口号`来标识
- 当一个`TCP`报文段从网络到达主机时，该主机使用全部四个值来讲报文段定向分解到相应的`socket`
- 两个具有不同`源IP地址`或`源端口号`的到达`TCP`报文段将被定向到两个不同的`socket`，正好对应了`TCP`一对一面向连接的特性

```c++
//客户端向服务端发起连接(举得是TCP的例子)
//创建socket
sock = socket(PF_INET, SOCK_STREAM, 0);
//给socket赋予地址(port 和 IP)
memset(&serv_addr, 0, sizeof(serv_addr));
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
serv_addr.sin_port = htons(atoi(argv[2]));
//调用 connect 函数向服务器发送连接请求
if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1)
```

服务器主机可以支持很多并行的`TCP socket`，开多个进程，一个进程对应处理一个`socket`信息，对应服务器编程的多路复用。毕竟，`TCP`是面向连接的协议，只能一对一，除非上一个连接已经关闭了，所以一个进程处理一个连接正好。后来的高性能服务器编程里使用的是多线程处理连接请求，一个主线程监听`listenfd`，通过`IO复用`技术，分配不同任务给线程池里的线程。

- 如果客户与服务器使用持续`HTTP`，则在整条连接持续期间，客户与服务器之间经由同一个`server_socket`交换`HTTP`报文。
- 如果客户与服务器使用非持续`HTTP`，则对每一对请求/响应，都创建一个新的`TCP`连接并在随后关闭。这种套接字的频繁创建和关闭影响一个繁忙的`Web`服务器性能（正好对应了`TinyWebServer`的`长连接`和`短连接`）

### 无连接运输：UDP

### 可靠数据传输原理

`rdt: 可靠数据传输协议(reliable data transform protocol)`

`FSM: 有限状态机(Finite-State Machine)`

**经完全可靠信道的可靠数据传输: rdt 1.0**

**经具有比特差错信道的可靠数据传输: rdt 2.0**

此时我们引入新的底层信道模型，此时信道中的分组比特可能受损，且继续假定所有发送的分组将按其发送顺序被接收

现在我们知道底层模型没有那么强大的能力，假设自己作为发送方，我是不能确定我`send`数据是否被成功接收。所以，我需要发送方给我一个确认。而如果回复接收不正常，我需要重新发送这份数据，否则会缺失。

而对于接收数据方，如果数据接收正常，回复`ACK`，如果数据不正确，回复`NACK`。这会使得发送方重新发送该接收有误数据。基于这样重传机制的可靠数据传输协议被称为自动重传请求（`ARQ协议`）

`ARQ`协议还需另外三种协议功能来处理比特差错的情况

- 差错检测：需要一种机制来使接收方检测到何时出现了比特差错，比如之前`UDP`的`检验和字段`
- 接收方反馈：发送方需要知道信息是否被正确接收，所以需要接收方的反馈信息（`ACK、NACK`）
- 重传：接收方收到有差错的分组时，发送方将重传该分组报文

> `rdt 2.0`的缺陷

**我们没有考虑到`ACK、NACK`受损的可能性，如果`receiver`回复的过程出错了，那么发送方如何知道对方是否收到了数据?**

假设发送方是`sender`，接收方是`receiver`

- 当`sender`接收到不清楚的`ACK`时，直接重传之前的分组即可，然后等待`receiver`的下一次回复。但是这有一个问题，`receiver`并不知道`sender`发送的这个数据时重传的数据还是新的数据，这会导致旧数据的重复或是新数据被丢弃。

所以我们还需要引入新的字段，也就是`序号`。在数据分组中添加新的字段，让发送方对数据分组编号。接收方只需检查序号即可确定收到的分组是否是重传数据。而这里的序号，使用`1 bit`就够了，表示两种情况，重发数据和新数据。

- 差错检测
- 接收方反馈
- 序号
- 重传

**经具有比特差错的丢包信道的可靠数据传输: rdt 3.0**

现在假定除了比特损坏外，底层信道还会丢包。现在协议需要处理另外两个问题，怎样检测丢包以及发生丢包后该做的处理？

丢包处理其实也简单，发送方重传一次数据包就行。但是，`sender`发送数据给`receiver`，该数据包在网络中丢失，`receiver`等待`sender`的数据包后才能判断序列号给出回应，`sender`等待`receiver`的`ACK、NACK`后才可以继续发送数据或是重传。**这就造成了一个互相等待对方的死锁情况**。所以需要定时器的引入，超过一段时间后发送方重新发送报文。

> 定时器的时间设置？

`RTT: 一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值`

所以我们将超时重传时间`RTO`设置为略大于`RTT的值`

- `RTO`较长：超过`RTT`很多，已经能确认这个报文没到达了，结果还不赶快重传，这就降低了网络效率

- `RTO`较短：可以正常发送接收到报文，但在`sender`接收到确认报文之前，定时器触发超时重传，`sender`又重发一次之前数据，`receiver`需要重复回应。结果回应报文到达之前，又会触发超时重传。。。

**流水线可靠数据传输协议**

`rdt 3.0`功能正确，但是性能不高，特别是对于高速网络而言。因为它是一个停等协议。

> 我们来计算一下`sender`实际发送数据的效率(将数据段完全送入信道)

假设`A -> B 且 RTT = 30MS`，彼此通过一条发送速率为`R = 1Gbps`的信道相连，现在发送方要将一个分组发进入链路所需要的实际时间为`L = 8000 bits`
$$
t_{trans} = {L \over R} = {8000bit/pkt\over10^9bit/s} = 8us/pkt
$$
数据发送到对面，需要`1/2 RTT`时间，对面再返回一个报文，全部数据进入信道的时间忽略掉，返回又需要`1/2 RTT`时间。假设第一个`bit`到达`A`，`A`就可以继续发送数据。那么`A`一次的发送时间为`RTT + trans`

**则`A`发送数据的利用率为**
$$
U_{sender} = {{L / R} \over {RTT + L/R}} = {0.008 \over 30.008} = 0.00027
$$
可见实际将数据传入信道的时间占比非常的少，数据在信道中传输的时间都被浪费了，这些时间应该被`A`利用起来，持续的发送数据。所以我们引入滑动窗口的设置，那些已被发送但还未被确认的分组的序号范围可以被看做是一个在序号范围内长度为`N`的窗口。

### 面向连接的运输: TCP

