## 左值和右值

C/C++语言中可以放在赋值符号左边的变量，即具有对应的可以由用户访问的存储单元，并且能够由用户去改变其值的量。

左值表示存储在计算机内存的对象，而不是常量或计算的结果。或者说左值是代表一个内存地址值，并且通过这个内存地址，就可以对内存进行读并且写（主要是能写）操作；这也就是为什么左值可以被赋值的原因了。

相对应的还有右值：当一个符号或者常量放在操作符右边的时候，计算机就读取他们的“右值”，也就是其代表的真实值。       

**简单来说就是，左值相当于地址值，右值相当于数据值。右值指的是引用了一个存储在某个内存地址里的数据。**

- 左值表达式可以分为可读写的左值和只读左值。
- 右值是可以出现在赋值表达式右边的表达式，他可以是不占据内存空间的临时量或字面量，可以是不具有写入权的空间实体。

```c++
int a = 3;
const int b = 5;
a = b + 2; 		 //a是左值，b+2是右值
b = a + 2; 		 //错！b是只读的左值但无写入权，不能出现在赋值符号左边
(a = 4) += 28; 	 //a=4是左值表达式，28是右值，+=为赋值操作符
34 = a + 2; 	 //错！34是字面量不能做左值
```

## 右值引用

```c++
int i = 10;
int &j = i;  //左值引用
int &&k = i; //右值引用
```

右值引用主是要用来解决`C++98/03`中遇到的两个问题

- 第一个问题就是临时对象非必要的昂贵的拷贝操作
- 第二个问题是在模板函数中如何按照参数的实际类型进行转发

通过引入右值引用，很好的解决了这两个问题，改进了程序性能

```c++
int i = getData();
```

- 从`getData()`获取一个整型值，这是一个临时值，在这个表达式结束后就被销毁了
- 左值`i`在表达式结束后仍旧存在

```c++
int &&i = getData();
```

这里使用了右值引用，右值是匿名变量，只能通过引用的方法得到右值。

在这里，`getData()`产生的临时值不会像之前那样，随着表达式结束就消失。反而，其生命周期因为右值引用得以延续，和`i`的生命周期一样长。

## 案例探索右值引用带来的性能优化

```c++
#include <iostream>

int construct_count = 0;
int copy_construct_count = 0;
int destruct_count = 0;

class A
{
public:
    A() {
        std::cout << "construct: " << ++construct_count << std::endl;
    }

    A(const A& a) {
        std::cout << "copy_construct_count: " << ++copy_construct_count << std::endl;
    }

    ~A() {
        std::cout << "destruct_count: " << ++destruct_count << std::endl;
    }
};

A GetA()
{
    return A(); //返回时调用一次拷贝构造函数
}

int main(int argc, char* argv[])
{
    A a = GetA(); //赋值是调用一次拷贝构造函数

    return 0;
}
```

```c++
construct: 1
copy_construct_count: 1
destruct_count: 1
copy_construct_count: 2
destruct_count: 2
destruct_count: 3
```

- 在函数中调用`A()`，出现第一次`construct`
- `return A();`出现第一次`copy_construct_count`，拷贝`A()`得到的临时匿名对象
- 函数结束，`A()`得到的临时匿名对象被销毁，出现第一次`destruct_count`
- `A a = GetA();`出现第二次`copy_construct_count`
- 该表达式结束，因为`return A()`被复制的临时对象被销毁，出现第二次`destruct_count`
- `main()`结束，`a`对象被销毁，出现第三次`destruct_count`

**经过编译器优化之后**

```c++
g++ main.cpp -o main
    
construct: 1
destruct_count: 1
```

**使用右值绑定返回值**

```c++
int main() 
{
    A&& a = GetA();

    return 0;
}
```

```c++
g++ main.cpp -fno-elide-constructors -o main
    
construct: 1
copy_construct_count: 1
destruct_count: 1
destruct_count: 2
```

- 在函数中调用`A()`，出现第一次`construct`
- `return A();`出现第一次`copy_construct_count`，拷贝`A()`得到的临时匿名对象
- 函数结束，拷贝`A()`得到的临时匿名对象被销毁，出现第一次`destruct_count`
- 接下来因为右值引用的原因，返回的临时匿名对象生命周期变长，我们直接引用了数据，而不是结束表达式就结束这个临时匿名对象的声明周期
- `main`结束，`a`对象被销毁，出现第二次`destruct_count`

## 第二个案例

```c++
#include <iostream>
using std::cout;
using std::endl;

class A
{
public:
    A() : m_ptr(new int(0)) { }
    A(const A& a) : m_ptr(new int(*a.m_ptr)) {  //深拷贝的拷贝构造函数
        cout << "copy construct" << endl;
    }
    A(A&& a) : m_ptr(a.m_ptr) {
        a.m_ptr = nullptr;
        cout << "move construct" << endl;
    }
    ~A() { 
        delete m_ptr;
    }

private:
    int* m_ptr;
};

A Get()
{
    A a;
    return a;
}

int main()
{
    A a = Get(); 
	
    return 0;
} 
```

```c++
g++ main.cpp -fno-elide-constructors -o main
 
move construct
move construct
```

上面代码中的`GetA()`会返回临时变量，然后通过这个临时变量拷贝构造了一个新的对象`a`，临时变量在拷贝构造完成之后就销毁了。

**如果堆内存很大的话，那么，这个拷贝构造的代价会很大，带来了额外的性能损失。** 每次都会产生临时变量并造成额外的性能损失，有没有办法避免临时变量造成的性能损失呢？

```c++
#include <iostream>
using std::cout;
using std::endl;

class A
{
public:
    A() : m_ptr(new int(0)) { }
    A(const A& a) : m_ptr(new int(*a.m_ptr)) {  //深拷贝的拷贝构造函数
        cout << "copy construct" << endl;
    }
    A(A&& a) : m_ptr(a.m_ptr) {
        a.m_ptr = nullptr;
        cout << "move construct" << endl;
    }
    ~A() { 
        delete m_ptr;
    }

private:
    int* m_ptr;
};

A Get()
{
    A a;
    return a;
}

int main()
{
    A a = Get(); 
	
    return 0;
} 
```

```c++
g++ main.cpp -fno-elide-constructors -o main
 
move construct
move construct
```

```c++
A(A&& a) :m_ptr(a.m_ptr)
{
    a.m_ptr = nullptr;
    cout << "move construct" << endl;
}
```

这个构造函数并没有做深拷贝，仅仅是将指针的所有者转移到了另外一个对象，同时，将参数对象`a`的指针置为空，这里仅仅是做了浅拷贝，因此，这个构造函数避免了临时变量的深拷贝问题。

上面这个函数其实就是移动构造函数，他的参数是一个右值引用类型，这里的`A&&`表示右值，为什么？前面已经提到，这里没有发生类型推断，是确定的右值引用类型。为什么会匹配到这个构造函数？因为这个构造函数只能接受右值参数，而函数返回值是右值，所以就会匹配到这个构造函数。这里的`A&&`可以看作是临时值的标识，对于临时值我们仅仅需要做浅拷贝即可，无需再做深拷贝，从而解决了前面提到的临时变量拷贝构造产生的性能损失的问题。这就是所谓的移动语义，右值引用的一个重要作用是用来支持移动语义的。

**需要注意的一个细节是，我们提供移动构造函数的同时也会提供一个拷贝构造函数，以防止移动不成功的时候还能拷贝构造，使我们的代码更安全。**

我们知道移动语义是通过右值引用来匹配临时值的，那么，普通的左值是否也能借助移动语义来优化性能呢，那该怎么做呢？事实上C++11为了解决这个问题，提供了`std::move`方法来将左值转换为右值，从而方便应用移动语义。`move`是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的`move`语义。

```c++
{
    std::list< std::string> tokens;
    //省略初始化...
    std::list< std::string> t = tokens; //这里存在拷贝 
}
std::list< std::string> tokens;
std::list< std::string> t = std::move(tokens);  //这里没有拷
```

如果不用`std::move`，拷贝的代价很大，性能较低。使用`move`几乎没有任何代价，只是转换了资源的所有权。

**他实际上将左值变成右值引用，然后应用移动语义，调用移动构造函数，就避免了拷贝，提高了程序性能。**

如果一个对象内部有较大的对内存或者动态数组时，很有必要写`move`语义的拷贝构造函数和赋值函数，避免无谓的深拷贝，以提高性能。事实上，C++11中所有的容器都实现了移动语义，方便我们做性能优化。

## 参考转载

- [(199条消息) c++11右值引用_with_dream的博客-CSDN博客_c++右值引用](https://blog.csdn.net/with_dream/article/details/85137039)
- [(199条消息) C++：浅谈右值引用_Dr. Lin的博客-CSDN博客_右值引用](https://blog.csdn.net/tonglin12138/article/details/91479048?ops_request_misc=%7B%22request%5Fid%22%3A%22164701399116780274175939%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164701399116780274175939&biz_id=0&spm=1018.2226.3001.4187)
- 





