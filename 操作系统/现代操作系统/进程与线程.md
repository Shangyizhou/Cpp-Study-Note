## 进程与线程

### 进程

假设一个网络服务器正在运行，然后有一些客户端请求服务器的资源。那么，服务器会在磁盘内获取数据然后将数据传给客户端，请求有很多种，如果能够拥有多个磁盘，那么就可以`同时`对多个磁盘发起请求。显然，我们需要一些方法来模拟控制这种并发，进程和线程就特别适合。

在多道程序设计系统中，`CPU`又一个进程快速切换到另一个进程，使每个进程固定运行几十或几百毫秒。严格的说，在某一瞬时时刻，`CPU`只能在某个进程中运行，但在`1s`内，`CPU`运行多个进程，给人产生并行的错觉。

**进程模型**

一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念说，每个进程都拥有它自己的`虚拟CPU`（实际上是一个`CPU`来回切换）。**这种快速的切换叫做多道程序设计**

程序计数器也被抽象成了多个，实际也只有一个程序计数器，不过在多个程序之间来回切换。 

**进程的创建**

四种主要事件会导致进程的创建

- 系统初始化
  - 启动操作系统时会创建多个进程，比如前台进程`Shell`；还有一些后台进程，比如收发电子邮件的进程，平日里沉睡，等到有信息的时候才被唤醒。还有诸多的守护进程，守护进程不受终端控制。
- 正在运行的程序执行了创建进程的系统调用
  - `Unix`只有一个创建进程的系统调用，`fork`系统调用
- 用户请求创建一个新进程
  - 在图形化操作系统中双击图标启动程序，也是开启一个新进程
- 一个批处理作业的初始化

总结这些情况，新进程都是由一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程可以是一个运行的用户进程，一个由键盘鼠标启动的系统进程或者一个批处理管理进程。

`Unix`使用`fork`系统调用创建新进程，这个系统调用会创建一个与调用进程相同的副本，父子进程具有相同的内存映像，同样的环境字符串和同样的打开文件。子进程接着执行`execve`系统调用，以修改内存映像并运行一个新的程序。

我们在`shell`中输入`sort`，`shell`进程创建一个新的进程，然后子进程用于执行`sort`命令。分两步是为了在`fork`之后但在`execve`之前允许孩子进程处理其文件描述符，可以完成对标准输出，标准输入，标准错误文件的重定向

进程被创建之后，父子进程拥有各自不同的地址空间。但是不可写的内存是共享的，这样可以节省空间。或者子进程共享父进程所有内存，但这种情况下内存通过写时复制共享，一旦两者之一要修改部分内存，则这块内存会被复制，以确保修改发生在私有内存区域。

**进程的终止**

终止条件

- 正常退出
- 出错退出
- 严重错误
- 被其他进程杀死

`Unix`调用`exit`终止进程

**进程的层次结构**

在某些系统中，进程创建许多子进程，那么父进程和子进程们以某种形式保持关联。

- **在`Unix`中，进程和它的所有子进程以及后裔共同组成一个进程组**。当用户从键盘发出一个信号时，该信号被送给与键盘相关的进程组的所有成员。
  `Unix`在初始化自己的时候，会启动`init`特殊进程，它开始运行并读取说明终端数量的文件，然后为每个终端创建一个进程。这就是一个进程组，它们都可以收到信号。如果一个用户登录成功，该登录进程就会执行一个`shell`准备接收命令，所接收的命令会启动更多的进程。所有的进程都属于以`init`为跟的一棵树
- 在`Windows`中，所有进程地位平等，但是父进程会得到一个句柄，句柄可以用来控制子进程，它也有权将句柄传送给其他进程

**进程的状态**

```c++
cat file | grep tree
```

可能会发生这种情况，`grep`程序准备就绪，但是`cat`命令还没有准备好数据，所以`grep`必须阻塞等待数据就绪。

一个进程在逻辑上不能继续运行时，它就会被阻塞。

进程的状态

- 就绪态（该时刻进程占用`CPU`）
- 就绪态（可运行，但是其他进程占据`CPU`）
- 阻塞态（不可运行，即使该进程占据`CPU`）

![image-20220223224226886](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220223224226886.png)

- **转换一**

进程可以执行`pause`系统调用阻塞进程，从而使该进程进入阻塞状态。或者当一个进程要从管道中读取数据，但是管道内无数据时，也会被阻塞

- **转换二和转换三**

这是由调度程序引起的，系统认为一个运行进程占用`CPU`时间足够了，就会让其他进程占用`CPU`，这会发生`转换二`。而其他进程也占用`CPU`到达时限了，系统又会将`CPU`给会原来进程使用，这时发生`转换三`

- **转换四**

当进程等来一个外部事件发生时（比如一些输入到达），则发生转换四，如果此时没有其它进程运行，则会立即触发转换三，该进程运行

**进程的实现**

操作系统维护着一个结构数组——进程表。每个进程占用一个进程表项（即`PCB：进程控制块`）其中包含了进程相关的重要信息

- 程序计数器
- 堆栈指针
- 内存分配情况
- 所打开文件的状态
- 账号和调度信息
- 其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，像从未中断一样

![image-20220223224950977](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220223224950977.png)

所有的终端都从保存起存其开始，对于当前进程而言，通常是保存在进程控制块中。相当于要切换进程了，把当前相关的资料都保存到某个数组当中，等切换回去了，就从这个数组中拿出数据恢复到当时的样子。

### 线程

> 举个例子

假设电脑处理要给文档，有`800`页，我们在第`10`页修改了一处，然后需要跳转到第`600`页继续修改一处位置，于是字处理软件会被强制对前`600`页进行处理（前面的改动会影响后面的格式），而在第`600`页的页面出来之前，计算机可能会运算很久，这会带来很不好的用户体验。（因为是单线程处理情况）

我们可以创建一个线程，第一个线程在第一处修改文字，第二个线程知道修改后就在后台重新处理格式。这样大概率会赶在显示页面前对这些页面的格式进行重新修改。

我们还可以再创建一个线程用于将文件保存在磁盘（自动保存）

**如果在这里不是使用三个线程，而是使用三个进程会怎么样？**

显然，这是不可以工作的。我们是要对同一个文件进行处理，保存。而进程都有各自的虚拟地址空间，其共享的部分也是只读不能修改的，如果修改就会牵扯到写时复制的操作。但是，线程之间是共享地址空间和全局变量的，所以可以对同一地址空间进行修改。

> 再来个`WebServer`的例子（项目有涉及）

`TinyWebServer`的主线程进行事件循环，监视`listenfd`，从网络中读取请求，然后分发任务给工作线程，工作线程可以处理`IO`操作，处理数据。没有任务时，工作线程处于阻塞状态，有任务时被唤醒执行相应函数。如果没有多线程，而只是单线程运行，那么`Server`接收请求，然后处理请求，比如调用`IO`操作，`IO`操作费时，这段时间`CPU`空转，不能利用起来。这段时间如果有请求到来，那么也不能被及时处理，使得一段时间只能解决很少的请求，使得`WebServer`的性能大大降低。

**经典线程模型**

> 什么是进程？什么是线程？

- 我们可以这么理解进程——**用某种方法将相关的资源集中在一起的一种抽象**。进程有存放程序正文和数据以及其他资源的地址空间，这些资源中有打开的文件，子进程，定时器，信号处理程序等。我们让进程对他们进行管理
- 另一个概念，进程中有一个用于执行的线程，线程中有程序计数器，用来记录执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还有一个堆栈，用来记录执行历史。**线程是在`CPU`上被调度执行的实体**

进程用于把资源集中在一起，而线程则是`CPU`上被调度执行的实体。（就算是但进程，它也有一个主线程的存在）

> 多线程（用于描述一个进程中运行多个线程的情况）

线程的存在给进程模型增加了一种可能性，即一个进程内同时并发运行多个线程。这些线程共享地址空间和其他资源。多进程是共享物理内存、磁盘、打印机和其他资源。

![image-20220224120822790](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220224120822790.png)

- `a)`每个进程都有自己的地址空间和单个控制线程（`CPU`通过在多进程内快速切换，营造多线程并行的错觉）
- `b)`一个进程带有三个控制线程，这三个线程在相同的地址空间运行 。
- 进程中的线程没有很大的独立性，各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读写另一个线程的堆栈，线程间没有保护。

> 线程内容分析

![image-20220224121811095](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220224121811095.png)

- **程序计数器：**
  多线程是通过各个线程的轮流切换并分配处理器的执行时间(cpu时间片)来实现的，同一时间处理器只能执行一条线程，为了线程切换后可以恢复到原来执行的位置，每条线程需要一个独立的程序计数器，各个线程的程序计数器互不影响，独立存储，这类内存区域为线程私有的内存。
- **寄存器：**
  跟进程类似，切换线程需要将寄存器的数据储存到
- **堆栈：**
  各个线程有自己运行的函数，其函数又会调用不同的函数，需要按顺序执行，所以需要拥有属于自己的堆栈，不能随便放置在内存中。每个线程的堆栈有一帧，共各个被调用但是还未返回的过程使用，该栈帧中保存了响应过程的局部变量以及过程调用完毕后的返回地址。
- **状态：**
  线程之间也有阻塞态，就绪态，运行态等。一个线程执行从键盘读入数据的系统调用，那么会阻塞住直到键入数据。

> **说法**：
>
> - 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行**资源分配和调度的一个独立单位。**
> - 线程是进程的一个实体,是**CPU调度和分派的基本单位，**它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
> - 一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。

> 线程库

不同于进程，线程库无法利用时钟中断强制线程让出`CPU`，所以只能自己调用`thread_yield`来让线程自己放弃`CPU`。

`POSIX线程:`定义了线程的标准，它的线程包叫做`pthread`

![image-20220224144910076](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220224144910076.png)

**在用户空间实现线程（协程）**

- 把整个线程包放在用户空间中，内核对线程包一无所知，从内核角度看，这就是一个单线程进程。
- 线程在一个运行系统上运行，该系统是一个管理线程的过程的集合
- 每个进程都需要有其专门的线程表（线程控制块），用来跟踪进程中的线程，它记录各个线程的属性，如程序计数器、堆栈指针、寄存器和状态等，该线程表由运行时系统管理，当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需要的信息。
- 如何实现阻塞系统，只要一调用系统调用并造成阻塞，所有线程都会被阻塞，因为对于内核，这就是一个进程内部含有一个线程，直接阻塞住了进程。

**优点**

- 用户级线程可以在不支持线程的操作系统上实现
- 线程切换方便，不会陷入内核态造成极大的开销
- 可以实现自己的调度算法

**在内核空间实现线程**

- 此时不需要运行时系统了，进程中也没有线程表了。由内核记录系统中的线程表
- 某个线程想创建新线程，它会调用系统调用，系统调用通过对内核线程表的更新完成线程创建或撤销工作
- 所有阻塞线程的调用都是以系统调用的形式实现，当然代价会更大。当一个线程阻塞，内核可以运行同一个进程中的另一个线程或者运行另一个进程中的线程
- 在内核中创建销毁线程代价过大，系统往往不会直接销毁创建，而是采取回收的策略。某个线程被撤销，该线程被标记为不可运行的，但是其内核结构不受影响。之后在创建新线程时，就重新启动某个旧进程。从而节省了开销

**问题**

- 信号是发送给进程的，那么进程中的多线程都会收到信号，由谁来处理？
- 多线程进程创建新的进程，新进程的线程是一个还是和原进程的线程一样多？

**混合实现**

- 使用内核级线程，然后将用户级线程和与某些或者全部内核级线程复用起来

### 进程间通信



## 参考

- [Linux下调用pthread库创建的线程是属于用户级线程还是内核级线程？求大神指教? - 知乎 (zhihu.com)](https://www.zhihu.com/question/35128513/answer/148038406)
- [用户级线程和内核级线程，你分得清吗？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/87272557)
- [大话操作系统 - 知乎 (zhihu.com)](https://www.zhihu.com/column/c_1167807113811386368)
- [也来谈谈协程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/147608872)
- 